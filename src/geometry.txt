
디퍼드
 - + position(depth?), specular, emissive... MRT 추가, 
 - 다중 광원, 이펙트 별도 처리, UI..

모션 블러, 비네트, SetAIState()
충돌체 가끔 고정댐, 높이맵 크면 안됨
AABB-OBB, 자기그림자
///// 1
@ MFC {
	- 뷰 추가, 클릭시 카메라 세팅
	- Instancer {
		+InstanceRenderer 리스트 -> 선택후 등록
	}
	- Animation, Line, Camera,
}
@ 파티클 {
	billboard + rotation시 회전 순서, 포인트 파티클, 
	Particle 상속(분열, sincos..),
}

- GetComponent 템플릿화
- 리사이즈 : 스크린 버퍼 확인
- 3d 이펙, 쉐도우 범위 밖.., 그림자
- Timer 남은 시간 sleep?
- 레이캐스트 + 거리 비교


GPGPU
툴 뷰 추가, 카메라 세팅
후처리 컴포넌트화
테셀레이션, 스플라인
쉐이더 동적 링킹(라이트 타입..)
멀티 쓰레드 랜더링
엔진 멀티 코어화
디퍼드 랜더링
캐릭터 가릴때 외곽선(스텐실)
높이맵 스케일

///// 2
@ 맵	: 공간분할, 컬링, LOD, 데칼, 높낮이, 워터맵
인스턴싱 쉐이더, 동적 큐브, 맵 경계 비침
행렬 Update 변경 있을때만?






@ 워터맵 {
	- 클리핑 : 평면과 점의 평면의 방정식 결과에 따라 뿌릴지 안뿌릴지 결정?
	- 포그   : 거리, 높이에 따라 특정 컬러 값을 연산해서 더해줌

	위 지형 텍스쳐, 위 지형 반사 텍스쳐, 하단 텍스쳐
	굴절, 반사(카메라 내려서 바라보는 뷰 행렬 만듬), 노말, 알파, 
}

@ 멀티 쓰레드 랜더링 {
	- 즉시 컨텍스트, 지연 컨텍스트
	- 컨트롤 리스트를 지연 컨텍스트에 멀티 쓰레딩으로 생성, 전부 생성후 즉시 컨텍스트로 랜더
	- 컨트롤 리스트 : 일련의 Setting 및 랜더 과정 모인거? 상태값이 바뀌지 않는다면 한번만 만들어도 됨
}


@ 루프-언롤링 : 반복문을 풀어서 코드를 처리, 속도는 증가하지만 코드 용량이 커짐. ([unroll]?)

@ 연산(Compute) 쉐이더 {
	- 범용 GPU(General-Purpose computing on GPU) 연산에 사용.
	- 다수의 병렬 프로세서를 사용해 처리함.

	- 스레드 그룹 인덱스      (SV_GroupID) : 
	- 그룹 스레드 인덱스(SV_GroupThreadID) : 
	- 그룹 인덱스		   (SV_GroupIndex) :
	- 배분된 스레드 인덱스 (SV_DispatchThreadID) : 
}

@ 쉐이더 동적 링크 {
	- Uber Shader : 한 쉐이더에 모든 기능을 때려 박은 단순 쉐이더.
	@ 쉐이더 클래스 {
		- 기본적인 클래스 기능 사용. virtual 키워드는 지원 X
		- 상수 버퍼에 클래스 인스턴스 지정, 변수 있을 경우 상수 버퍼로 지정
	}
	- 쉐이더 클래스만 링크 교체 시켜서 하나의 픽셀 쉐이더에서 처리 댐.
	- 리플렉션 : 쉐이더 파일에 있는 인스턴스 갯수, 클래스? 같은거 찾아줌.
	- 라이트, 행렬곱, 후처리, 노말, 환경 등등.. 여러가지..
}


@ PN트라이앵글 {
	- 헐 쉐이더		: 제어점(정점)과 패치 상수를 받아 테셀레이션에 넘김
	- 테셀레이터	: 넘어온 제어점과 패치 상수에 따라 엣지를 쪼개 정점을 나눠줌
	- 도메인 쉐이더 : 받은 제어점들을 정점으로 변환(..스플라인)
	무게중심좌표?
}


@ 곡선, 스플라인 {
	- 특정 곡선 알고리즘을 나타내는 행렬(방정식)에 따라 t값으로 선을 보간해 곡선이 만들어짐
	- 제어점   : 곡선의 흐름을 제어하는 구간점.
	- 스플라인 : 곡선 여러개를 구간별로 이어 붙인것.
	- 곡선 알고리즘의 결과값은 하나이지만, 내부적으로 여러개(제어점 갯수?)의 곡선이 블랜딩되어 만들어진다.

	- 곡선 파형의 제어 요소 {
		- 장력(Tension)		: 두 제어점 사이의 곡률의 양을 제어. 
							  -> 높을수록 선형 곡선, 낮을수록 둥근 곡선
		- 편향(Bias)		: 제어점 양쪽에 들어오는 곡선과 떠나는 곡선의 커브를 제어. 
							  -> 음수, 양수 : 들어올때와 떠날때 커브 생성, 0 : 균일하게 형성
		- 연속성(Continuty) : 제어점 양쪽 곡선의 부드러운 정도를 제어.
		- 완화(Easing)		: 시작점과 끝점의 속도 변화(가속도)를 제어.
							  -> Ease In : 점점 빨라짐, Ease Out : 점점 느려짐
	}
	* 베지어 곡선			: 제어점의 시작과 끝만 경유하고 중간점은 보간.
	//- 카디널 스플라인 곡선  : 모든 제어점을 경유함.
	* 허미트 곡선			: 두 제어점과 두 접선벡터를 이용. 접선벡터로 휘어지는 정도를 제어.(베지어와 결과는 비슷)
	- TCB-Spline			: 두 제어점과 두 접선벡터를 쓰고 Tention, Continue, Bias로 접선을 제어. (3ds Max에서 주로 쓴다캄)
	* 캣물롬				: 시작과 끝점을 제외하고 중간점만 경유, 연속된 곡선 처리에 유용
	- B-Spline				: 제어점의 수가 다항식의 차수와 무관, 모든 제어점을 경유하지 않는 근사 곡선.

@ 이선형 보간 : 픽셀과 픽셀 사이의 보간(x, y)
@ 삼선형 보간 : 보간된 텍스쳐와 다른 텍스쳐 사이의 보간(x, y, z) -> 밉맵 보간


@ 쉐도우 마스킹 {
	- 물체가 가리고 있는 부분의 조명 처리
	-   평면 쉐도우 : 물체의 정점과 빛(방향 or 위치)과의 연산으로 평면에 그림자를 띄움, D3DMatrixShadow
					- 물체와 지형을 한번 뿌린뒤, 그림자에 대한 텍스쳐를 뿌림
	-   투영 쉐도우 : 빛의 위치에서 물체를 바라보는 텍스처를 만들고, 텍스처끼리 비교해서 연산
	- 깊이맵 쉐도우 : 깊이값을 텍스처에 기입해 연산, 셀프 쉐도우(자기 자신의 그림자) 처리가 가능
					- 레스터라이저에 바이어스 값을 설정하여 깊이값의 오차를 줄여야 함, 깊이값에 바이어스값 더함
					- 빛의 위치, 방향에서 바라보는 텍스쳐를 만들고, 대상 물체에 빛 행렬을 곱했을때 픽셀이 같은지 비교(다를시 쉐도우 처리)
					- 만든 텍스처 크기에 따라 계단현상이 발생하여 PCF:SampleCmpLevelZero 함수로 블러 처리를 해줌(SS 필요 -> SamplerCompareState)
					- 직교 카메라로 깊이 버퍼에 값을 기입시켜
					- only 클램프?
			-> 바이어스 : 같은 깊이값이 기입될때 나중에 기입된거에 추가치를 줌
	- (스텐실) 볼륨 쉐도우 : 스텐실 버퍼를 이용. 
					@ 엣지 검출 : 트라이앵글의 선중 중복 선을 제거
					@ 스텐실 성공 {
						- 물체를 빛 방향으로 끌어당겨서 트라이앵글을 만듬? 쉐도우 볼륨 메쉬
						- But, 모든 정점을 만드는건 많고, 외곽선만 검출하여 스텐실 기입함.
						- 앞면 랜더시 스텐실 값+1, 뒷면 랜더시 -1시켜, 스텐실이 1일때만 쉐도우 처리.
						- ButBut, 카메라가 쉐도우 볼륨 내부로 들어가면 결과가 이상하게 나옴
					}
					@ 스텐실 실패 {}
}


@ 프리 이펙트 : 스텐실 이용
@ 포스트 이펙트 {
	- 랜더링된 텍스쳐 픽셀에 이미지 프로세싱(필터링)하는 작업
	- 일반 컬러 텍스쳐와 노말+깊이 텍스쳐를 랜더타겟 걸고, 따로 랜더링시킨뒤, 처리
	@ 블러 { 
		- 주변 픽셀과의 연산을 통해 픽셀의 컬러를 뭉게트림(+가중치)
		- 가우시안 : 픽셀간 거리에 따른 가우시안 곡선을 가중치로 두고 블러시킴
	}
	@ 샤프닝 {
		- 가운데 픽셀의 가중치를 크게 두고 주변 픽셀의 컬러를 빼어 선명한 효과를 줌
	}
	@ 외곽선(엣지) 검출 {
		- 노말과 깊이를 이용해 주변 픽셀과 차이를 비교하고 외곽선을 판단
		- 가로 마스크와 세로 마스크를 따로 주어 차이가 있는지 검사함
		- 캐릭터 외곽선 : 스케일 키운 캐릭터를 특정 색으로 랜더링후(깊이 기입 X) 원본 캐릭터를 랜더
		- 소벨 : 1 2 1 식으로 마스크, 대각선 엣지에 민감함
		- 프리윗 : 1 1 1 식으로 마스크, 조금 빠르지만 엣지가 덜 부각됨
	}
	@ 조명 텍스쳐 {
		- 라이팅 연산 결과를 텍스쳐의 uv값으로 사용해 뿌림
		- 라이트 맵 텍스처 : 단순한 컬러 대신 미리 만들어진 텍스쳐를 이용해 여러 표현
	}
	@ 지연 라이팅(디퍼드 랜더링) {
		- 
	}
	- 깊이맵
	- 깊이값을 컬러의 a값으로 두어 멀리 있을수록 흐리게
}


@ 메테리얼 {
	@ 환경매핑 {
		@ 큐브맵 {
			- 물체에 반사되는 환경을 매핑하기 위한 입방체(6면체)
			- 시선에 대한 반사 벡터를 큐브맵의 3d 텍스쳐 좌표로 사용
		}
		@ 반사와 굴절 {
			- 
			- 스넬의 법칙
		}
		@@ 프레넬 효과 : 반사율 {
			- 물체의 재질에 따른 반사율 변화, 미적용시 완전 반사
			- 연산량이 많아 프레넬 방정식을 간략화한 계수를 이용함
		}
		@ 정적 환경매핑 {
			- 미리 만들어진 큐브맵을 이용해 물체에 매핑시킴
		}

		@ 동적 환경매핑 {
			- 매 프레임 주변 환경 텍스쳐를 뷰 행렬을 달리해 6장 랜더링하고, 큐브맵을 만들고 그걸 이용해 맵핑
			@ MRT : 여러개의 랜더 타겟을 이용해 각각 텍스쳐 출력 {
				- 낱장 텍스쳐 : 
				- 텍스쳐 배열 : 
				- 큐브맵 생성 : 
				- 랜더타겟 배열을 이용해 픽셀 쉐이더에 랜더타겟을 지정해서 출력됨
				- 기하쉐이더를 이용해 한번의 입력으로 6번 출력
			}
			D3DX11SaveTextureToFile : 텍스쳐 파일로 저장
		}
	}

	@ 노말매핑 {
		- rgb값이 기입된 노말 텍스쳐를 픽셀의 노말값으로 사용해 텍스쳐의 음영(질감)을 표현
		- 로우폴리곤을 하이폴리곤처럼 보이게 하는 매핑 기술.
		- 물체에 노말값을 지닌 노말맵을 붙여 음영 계산에 사용.
		- 노말 텍스쳐와 면의 축을 맞추기 위해 접선 벡터를 넣음
		- 로우폴리곤, 하이폴리곤 오브젝트를 두고 차이로 뽑아냄.
		- 접선 공간에서 계산됨
	
		- 접선벡터(Tangent) : 법선에 수직인 벡터(면에 평행)
		- 종법선벡터(BiNormal) : 법선과 접선에 수직인 벡터
	}

	@ 범프매핑 : 높이 정보만 가진 그레이스케일 소스를 이용해 빛의 농담을 표현.

	@ 변위매핑(Displacement) : 물체의 실제 메쉬를 조절, 연산량이 많아 부적합. (Real-범프매핑)

	@ 시차매핑(Parallax) : 시선 방향을 고려해서 높이값을 이용해 텍스쳐 offset을 샘플링함(범프 < 노말 < 시차)

	@ 반사맵 : 물체의 반사 속성의 따라 입체감을 부여
	- 엠비언트 : 주변광 차단, 면과 면 사이에 빛이 덜 들어오게해 그림자 만들어 입체감을 줌
		
	@ 릴리프 매핑 : 실제 돌출되어 가려지지만 메쉬가 늘어나진 않음, (랜더링 트릭?, 연산 많음)

	@ 질감 : 물체에 적용할 빛에 대한 속성 {
		- Diffuse  (분산광) : 일정한 방향으로 들어오는 빛,		-라이트 벡터 ' 정점 노말
		- Specular (반사광) : 바라보는 시선에서 반사되는 빛,	-시선 벡터	 ' 라이트 반사 벡터
		- Ambient  (주변광) : 특정한 방향이 없는 빛, 빛이 없더라도 어느정도의 밝기를 보정
			-> Real Ambient : 주변 물체에 반사된 빛을 진짜 계산(간접조명)
		- Emission (방사도) : 스스로 발광하여 빛이 없어도 보임
		- Shininess(선명도) : 광원이 비추는 강도가 날카로워져 표면이 매끈하게 보임
		- Roughness(거칠기) : 물체의 거칠기
	}

	@ 레거시 렌더링 : 물리기반 렌더링 이전의 방식 {
		@ 기본색 : 난반사(Diffuse)  텍스처
				 - 물체에 깊이감과 입체감을 주고, 표면에 색을 부여
		@ 반사광 : 정반사(Specular) 텍스처
				 - 빛을 받았을때 물체의 광택(하이라이트)를 표현
		@ 거칠기 : 반사(Reflection) 텍스처
	}
	
	@ 물리기반 렌더링(PBR) : 표면의 재질에 따른 빛 반사를 물리적으로 시물레이션해 표현 {
		@ 기본색 : 기본색(Base Color)텍스처
		@ 반사광 : 금속성(Metallic)  텍스처
		@ 거칠기 : 거칠기(Roughness) 텍스처
	}
}


@ 라이트 {
	- 직접 조명 : 객체에 직접 들어가는 빛
	- 간접 조명 : 객체들 간에 상호 반사된 빛, 연산량↑
		   
	- 지역 조명 : 객체에 직접적으로 들어오는 것만 고려
	- 전역 조명 : 직접조명 + 간접조명, ex) 레이 트레이싱, SSAO,,

	@ 광원 : 빛이 들어가는 지점을 결정, 방향과 색을 가짐 {
		- 디렉셔널 라이트(태양광) : 거리에 상관 없이 빛의 방향만을 가짐
		- 포인트 라이트(위치광) : 특정 위치에서 모든 방향으로 퍼져나가는 빛, 거리:감쇠
		- 스포트 라이트(집중광) : 위치와 방향, 범위를 가지고 일정한 각도로 비춤
	}
	
	- 빛은 모든 광원이 발산한 조명 연산이 합산됨
	- 하프벡터 = (L벡터 + 시선 벡터) -> ' 정점노말
	- 강도 nor? 늘리면 밝아지고 좁아짐 줄이면 반대
	- 휘도, 각, 거리, 감쇄(빛은 선형보간으로 일정하게 줄어들이 않고 제곱처럼 줄어듬)

	@ 퐁쉐이딩 - 픽셀 쉐이더에서 픽셀 단위로 라이팅 연산
}





@ 기하감쇠 {
	- 빛이 반사되고 물체와 충돌하며 빛의 일부가 감쇠하는것.
	@ 마스킹 : 각 빛이 충돌한 지점을 통해 빛이 카메라에 전달되는 크기 계산
	@ 쉐도잉 : 카메라 위치에서 정점에 도달하기 전에 충돌되 일부만 전달되는것
			-> 빛이 물체에 차단되어 카메라에 전달되는 양 계산
			-> 가려지는 부분은 그림자가 됨
}
@ 쿡-토런스 공식 {
	- 기하감쇠 * 프레넬 방정식 * 거칠기 / ㅁㄴㅇ
	- 미세면(재질)에 따라 조명 감도 조절 가능
	s파 pos파
}



@ 텍스쳐 자동 생성(TCI) { - 예제:TCI_0 
	@ 월드 좌표 이용 {
		- 월드 좌표에 따라 텍스쳐 좌표를 0.0f ~ 1.0f 값으로 변환.
		- 타일링시 해당 타일 수(리프 노드) 만큼 연산해줌
	}
	@ 고저에 따른 텍스쳐 선택 {
		- 지형의 y을 이용해서 텍스쳐를 선택 
		  -> 문턱에 텍스쳐와 텍스쳐의 알파값을 주어 텍스쳐가 부드럽게 바뀌게 함
	 }
	- 뷰 반사 벡터
	- 투영 좌표를 이용해서 화면에 텍스쳐 고정?
	@ 스플래팅 {
		- 맵툴에서 지형 생성시, 마우스 찍은 지점에 알파 텍스처를 만듬
		- 텍스쳐를 따로 생성해서 해당 범위에 알파 텍스쳐를 덮어씌움(+지우기)
	}
	@ 싱글 타일링 {
		- 그냥 마우스 지점에 타일링함
	}
	@ 오토(브릿지) 타일링 {
		- 미리 타일 텍스쳐를 만들어두고 찍은 지점에 해당하는 텍스처를 뿌림
		- 4개의 타일을 하나의 세트로 보고 번호를 부여해 좌표 지점의 텍스쳐를 뿌림(+연결)
		- 같은 형태의 타일 중에서도 여러개 만들어두고 바리에이션 줌.
	}
	- createTangentSpaceVectors : 텍스쳐 저장 유틸
}

@ 맵 고저 변경 {
	- 피킹 범위의 지형 정점을 찾아 y값을 변경.
	- 거리에 따라 tex값 보간을 해서 con으로 하던 뭐 해서 차이를 줌
	- 평지화 : 피킹 지점의 y 값으로 범위 내의 지형 y값을 맞춤
}



@ UI, 이펙트 {
	- 이미지 확대, 축소가 필요할때 이미지를 9등분(uv조절) 시켜서 모서리가 늘어나지 않게함
		-> 랜더를 9번 하던가, 하나의 버텍스에 9개 면을 묶어 랜더링
	- 텍스트는 늘리면 깨지니 늘리지 마셈
	- 아틀라스 텍스쳐 : 여러 텍스쳐를 하나로 합쳐 uv로 조절해 랜더함 -> 부하 줄임
	- 이미지에 알파 이미지를 합쳐서 여러가지 표현.. 알파 교체 랜더링?
}

@ 포인트 파티클 {
	점을 넘기면 기하쉐이더에서 그 점을 기준으로 정점을 만듦,
	스트림아웃풋스테이지, 기하쉐이더
	더블버퍼링처럼 버퍼를 교체해가며 cpu부와 gpu부가 연동
	프레임에서 기하쉐이더에 프레임 연산에 필요한 정보를 전달하고,
	기하쉐이더에서 그 정보를 가지고 연산후, 연산된 결과를 프레임에 전달.
	전달받은 프레임은 받은 정보로 드로우하고 새로 쉐이더에 그 정보를 넘겨줌,
	(샘플에선 rand를 표현하기 위해 텍스쳐의 rgb값으로 계산)
} to do : 17장, 24장, 인스턴싱, 기하쉐이더, SO스테이지, 파티클, 
연산을 쉐이더에서 처리하고 프로그램은 중계만
	-> 기하쉐이더에서 연산해서 넘기고, 다시 기하에서 연산넘기고..
	
@ 기하쉐이더 {
	Shader -> SampleLevel(, , level) 밉맵 레벨 조절
	기하쉐이더는 프리미티브 단위로 받음
	triangle로 보냈으면 trianglestream으로 추가해서 출력
	Create~StreamOut~()
	기하쉐이더에서 SO에 출력해서 응용 프로그램으로 전달함
	버퍼 두개 만들고 StreamTo, DrawFram~ 와리가리함, 보내고 받고 ~ 반복댐
	SOSetTargets(SO)를 하면 SO로 출력이 됨,
	기하에서 보낸 SO로 출력할땐 DrawAuto로 드로우
	Render, DrawAuto 부분만 봐도댐
	+17장, 18장, 24장
	이펙트 인스턴스, 모델 폭파
}

@ 멀티쓰레딩 {
	- CPU의 사용률을 높이기 위해 여러 쓰레드를 이용해 작업을 처리시킴.

	@ 초기의 멀티쓰레딩 : Frame과 Render부를 나눔(멀티코어)
		-> 코어의 수가 늘어남에 따라 안쓰는 코어 증가
	
	@ 잡 테스킹 : 작업 처리가 필요한 오브젝트 단위로 각 쓰레드에 분배시킴
				- ex) 800개의 오브젝트를 처리해야하고, 8개 코어.
					-> 8개의 쓰레드를 할당해 쓰레드 별로 100개의 오브젝트를 처리시킴.
	@ 배리어 락 : 오브젝트 처리의 분기점(Phisics, Animation...)당 락을 걸어 다른 쓰레드가 전부 처리됐을때 진행.
				-> 한 처리가 끝나야 다음 오브젝트 작업에 참조..
	@ 테스크 스틸링 : 오브젝트를 분배시킨다해도 모든 쓰레드가 균일하게 처리하긴 힘드니,
					  먼저 작업이 끝난 쓰레드가 다른 쓰레드의 작업을 뺏어옴.
	@ 페러렐(병렬) 알고리즘,,
}


@ 캐릭터 애니메이션{
	- 오브젝트 정보 : 캐릭터가 아닌 일반 객체
	- 스킨 정보	   (살:메쉬) : 부위별 파트에 대한 정보를 각각 저장
	- 애니메이션 정보(뼈:본) : 매트릭스 형태로 저장, 분리된 애니메이션이라면 여러 파일
	- 특정 구간의 프레임만 애니메이팅, (몹-인.여-남자-스왑)
	
	@ 스키닝 애니메이션 {
		- 블랜딩 오브젝트   : 정점당 1개 이상의 행렬이 가중치를 가지고 곱해짐(한 정점의 행렬의 가중치 합 = 1.0?), 정점	하나라도 블랜딩일시 블랜딩
		- 논블랜딩 오브젝트 : 모든 정점이 정점당 1개의 서로 다른 행렬이 곱해짐
	
		-> 정점에 해당하는 행렬 인덱스와 가중치를 추가 
		-> 상수 버퍼에 행렬 정보 배열을 넘기고 정점에 해당하는 행렬 번호를 가지고 가중치와 곱해서 계산
	}
	- 스킨 모디파이어 : 스킨
	- 캐릭터 스튜디오 : 피지크, 스킨 데이터?

	- 바인드 포즈 애니메이션 : 스킨 NodeTM의 역행렬을 곱해서 월드 정점을 바이패드 공간으로 변환하고 애니메이션 곱?

	- 캐릭터 가중치 6개 있다치면 높은거 4개 정도만 써도 충분
	- 캐릭터 애니메이션 행렬 SRT값 매번 계산 없이 해당 프레임에 미리 계산된 행렬 이용하고, 프레임만 보간?

	// 헬퍼, 지오 합치고 메쉬 부분만 따로 체크?  -> SetBinpedInfo()
}




@ LIB : 정적 라이브러리 {
	- Link 단계에서 라이브러리(.lib)가 실행 파일 안에 포함됨
	- lib 파일이 변경되면 실행 파일도 다시 만들어야함
	- 실행 파일의 크기가 커지고, 여러곳에서 포함 시킬 경우 비효율적
	- 정적 라이브러리의 .lib은 전체 코드가 binary화 된것
}
@ DLL : 동적 라이브러리 {
	- dll 파일을 만들고 실행 파일에서 불러와 사용
	- dll 함수를 외부에 공개하려면 __declspec(dllexport) 키워드 필요.
	- 함수 앞에 extern "C" 설정시 함수 이름을 col 형식으로 출력해줌
	- DUMBBIN : dll 파일 읽어서 볼 수 있음

	- 암시적 링킹 : dll + lib을 사용해 lib를 포함
	{
		- 실행시 lib가 dll 파일 정보를 찾아 불러옴, header 필요
		- DX Lib 경우도 .lib를 포함시켜 dll 파일을 로드한것.
	}
	- 명시적 링킹 : dll만 넣고 실행중 dll을 로드
	{
		- lib나 header가 필요 없고, 실행중 원할때 동적으로 불러올 수 있음.
		- 실행중 dll을 LoadLibrary로 불러오고, 사용할 함수를 불러와 포인터에 넣고 사용(불편..)
	}
	
	// DllMain 형식
	BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG fReason, LPVOID lpReserved) 
	{ return TRUE; }
}


@ Max SDK Plugin Exporter {
	- 3ds Max 폴더 Plugins에 dll을 넣어두면 Max에서 읽어줌
	- dll 규칙 : 생성시 기호 내보내기, def 파일 생성(함수 공개)
	- Exporter 함수 정의, SceneExport 상속후 가상함수 정의, ClassDesc2 상속-정의
	- Max header들 연결하고, 내용들 읽어서 출력
}


@ 인스턴싱 {
	- 같은 정점 버퍼와 인덱스 버퍼를 공유하는 객체들끼리 묶어 한번에 드로우
	- 레이아웃 생성시 PNCT 등 기본 정보와, SRT 행렬, 컬러 등을 나타내는 개별 정보를 넘겨 그 구조체에 값을 입력함
}




@ 충돌 처리 {
	@ AABB : 축에 정렬된 바운딩 박스
	@ OBB  : 기울어진 바운딩 박스 {
		- 각 축의 x, y, z 를 평면에 내적 -> 중심과 평면 내적과 비교
		- vs 점 : 중심 x,y,z
	}

	@ 점 
		- vs 점   : 거리구해서 0에 가까우면 충돌
		- vs 선   : 점1과 선 내부의 점2과 를 내적 -> 점2를 선 방향으로 내적량만큼 이동, 그 점과 점1의 거리를 비교
		- vs 평면 : 면의 노말과 점을 내적 -> 0에 가까우면 충돌
		- vs 구   : 구 중심점과 점의 거리와 반지름을 비교
		- vs AABB : 점과 각 축 min, max를 비교
		- vs OBB  : 박스 중심점 xyz 축과 점을 내적하고 결과가 각 축 반지름보다 작을시 충돌
	@ 선
		- vs 선   : 선과 선 내적 -> 평행 여부, 선과 다른 점 2개 외적 -> 선과의 교차 여부, 
		- vs 평면 : 면의 노말과 선의 방향을 내적 -> 0이면 평행, 
		- vs 구   : 구의 중심점과 선 내부의 점을 내적, 내적량만큼 이동하고, 거리가 반지름보다 가까운지 비교
		- vs AABB : 
		- vs OBB  : 


	@ 점 충돌테스트	 - 점과 삼각형 각점을 외적시켜 부호 판단해 충돌했는지 확인

	@ 마우스 피킹 {
		- 교점 찾기
			- 1. 평면의 노말과 레이를 내적해 ~ tex(0.0 ~ 1.0)를 구하고, 레이의 방향으로 tex만큼 갔을때 거리가 distance와 같아야 함
		- 교차된 점이 폴리곤에 들어왔는지
			-> 1. 폴리곤의 각 선분과 점을 외적, 외적한 결과의 방향이 하나라도 다를시 불충돌
			-> 2. uv 매개변수 사용 : 교점(P)을 두개의 벡터로 분해해(a, b), 각 엣지벡터?가 0보다 크고 두 벡터의 합이 1보다 작으면 포함
			-> 3. 점과 삼각형의 내각의 합이 180도(잘안씀)
		
		- 클래머 공식 : 행렬들의 행렬식을 계산하고 tex,u,v/행렬식 인가를 하면 수반 행렬이 나온다캄
		
		- 삼중적 : 내적과 외적이 결합된 공식 -> 각 벡터의 위치를 돌려도 결과가 같다 ex) a ' (b x col) = b ' (col x a)
					- 부호를 바꾸면 외적 변수의 위치가 바뀜(외적 방향이 바뀌니)
					- 행렬식의 결과는 삼중적으로 표현 가능
					C ' ( A x B) = { Cx, Cy, Cz,
									 Ax, Ay, Az,
									 Bx, By, Bz }
		
		평면-세그먼트 교점(GetIntersection) : tex, 
		포인터-폴리곤 포함(Point in Polygon): uv, 
		교점 + 포함(IntersectTriangle) -> 클래머, 삼중적 : 최적화 짱
	}
}



@ 공간 분할 {
	@ BSP(Binary Search Partitioning)
		- 실내 지형의 공간 분할 알고리즘
		- 지형의 면(삼각형)중 BestPlane:(나눈 면의 갯수 차가 가장 적은 면)을 찾아 2진 트리 구조로 나눔
		- 선택된 면과 다른 면들이 앞에 있는지, 뒤에 있는지 검사하고 -> 만약 면과 면이 교차 할 경우, 쪼갬
		- 교차된 삼각형의 교차된 선과 점들을 다시 연결해 삼각형으로 나눔(2:1, 1:2), 
		- 점이 정확히 교차할 경우 연결하지 않고 양쪽 노드에 추가
	
	@ 솔리드 BSP : 지형과 외곽 지형을 나눠 타겟이 지형 어느곳에 있는지 찾고, 외부 공간에 있으면 바로 충돌처리 가능
	@ 포탈 랜더링 : 방으로 된 공간에서 포탈(문)을 달아 연결된 곳을 찾고, 볼 수 있는지를 검사
	
	
	
	@ 랜더 타겟
		- 텍스쳐를 생성해 뷰포트로 잡고 그리고, 쉐이더에서 후처리후, 화면에 적용
		- 랜더링후 백버퍼로 다시 교체
	
	@ 쿼트 트리
		- 지형을 루트노드와 그 노드를 4개로 쪼갠 자식 노드로 나눠 분할하는 방식,
		- 트리의 깊이와 지형의 길이를 넣어 조절
		- 리프 노드(타일) 단위 랜더링을 기본으로 잡고, 
			1. 정점 버퍼 하나와 인덱스 버퍼 하나
			2.* 정점 버퍼 하나와 노드별 인덱스 버퍼 *
			3. 노드별 정점 버퍼과 공용 인덱스 버퍼
			4. 정점의 요소를 쪼개 P, N, C, T로 레이아웃 구성 or 텍스쳐만 따로
			
	@ 옥트리
		- 지형을 x, y, z축으로 8개씩 쪼갬, 객체간에 높이차가 많을때 유용

	@ 프러스텀 
		- 카메라가 바라보고 있는 물체만 랜더링 하기 위해, 프러스텀 영역 외 나머지 물체를 컬링 처리함
		- 카메라 투영 좌표 각 정점(-1~1) * 역 투영행렬 * 역 뷰행렬 = 프러스텀 박스 정점
		- 프로스트럼 박스 면의 
		- 공간분할 - 구
}

@ LOD(Level Of Detail)
	- 정점의 거리에 따라 디테일 레벨을 다르게 둠.
	- 지형의 경우 타일의 요소를 더 쪼개 정점을 구성하고, 뿌리는듯
	- 정점의 디테일을 달리하면 옆의 패치와 틀어져서 구멍이 뚤릴 수 있음,
	- 인덱스를 여러 종류 만들어서 옆의 패치와 맞는 인덱스를 사용하도록 함 (방사형, 십자형)
	- 쿼드 트리를 구축할때 주변 노드와의 관계(포인터) 또한 같이 두어,
		옆의 노드와 레벨 차이로 어떤 인덱스를 사용할지 선택
	- 인접한 거리는 LOD 선정 간격을 길게 두고, 점진적으로 길게 두는식으로 하는게 나음
	* 노드 간의 높이 차이가 급격히 벌어지거나, LOD 선정 간격이 좁아 레벨이 2 차이 이상 날시, 구멍을 메꾸기 힘듬
	* LOD 레벨이 낮아지면 높이가 있는 정점이 무시될 수 있음



@ 선형보간(Linear Interpolation)
	- 시작점과 목표점 사이를 보간해줌, lerp = (1-time) * start + time * end
@ 구면선형보간
	- 원호상에서의 보간, 



@ 맵 : 각 정점의 높이값의 변화를 줘서 지형의 높낮이를 설정(ex - 파도)
	- 높이맵 : 지형의 높낮이를 표현, 텍스쳐의 각 픽셀은 정점에 대응

@ 정점 노말 벡터
	1. 전체 페이스 노말 계산,
		- 인덱스 리스트를 참조해 각 면의 노말을 구함
	2. 1개의 정점을 공유하는 모든 페이스 리스트 구축
		- 정점에 있는 룩업테이블에 정점끼리 공유하는 페이스를 구함( set쓰던지)
	3. 정점 노말 계산
		- 기본적으로 정점의 주변 6개 페이스의 노말 벡터를 더하고 정규화시켜 계산
		- 다만, 이미 정규화된 노말 벡터를 가지고 계산하면 페이스의 길이가 고려되지 않아 어색함.
		- 정규화 되지 않은 노말 벡터로 하는게 낫다캄.
	정점에 룩업테이블에 있는 노말들을  참조하는 노말 값을 더해서, 노말갯수로 나누고, 정규화
	구한 노말 벡터와 조명 연산,

@ 스카이박스
	- 각 6면에 해당하는 텍스쳐 불러오고(or 텍스쳐 좌표 변경?), 따로 랜더링
	- 컬링 none하고 z기입도 안하도록 -> 먼저 랜더링하던지, z값 비교해서 랜더 안된 부분만?샘플러 point로,
	- 큐브맵 : 텍스쳐 한장이 배열로 되어 3d 텍스쳐처럼 사용, 큐브or구에 맵핑              스위즐링?
	- 텍스쳐 쉐이더 파일에서 계산? SV = SystemValue,

@ 임의의 축 - 임의의 축에 대한 역행렬을 곱해 기저축으로 돌리고, 변환(SR)시킨뒤 다시 임의의 축으로 회전



사인	𝑦 / 𝑟 = 𝑠𝑖𝑛𝜃 , 𝑦 = 𝑟 sin𝜃		
코사인	𝑥 / 𝑟 = 𝑐𝑜𝑠𝜃 , 𝑥 = 𝑟 𝑐𝑜𝑠𝜃
탄젠트	𝑦 / 𝑥 = 𝑡𝑎𝑛𝜃 , 𝑦 = 𝑥 𝑡𝑎𝑛𝜃
 --> r이 1일때, x = cos𝜃, y = sin𝜃
 
코시컨트 𝑟 / 𝑦 = 𝑐𝑠𝑐𝜃 = 1 / 𝑠𝑖𝑛 𝜃
시컨트   𝑟 / 𝑥 = 𝑠𝑒𝑐𝜃 = 1 / 𝑐𝑜𝑠𝜃
코탄젠트 𝑥 / 𝑦 = 𝑐𝑜𝑡𝜃 = 1 / 𝑡𝑎𝑛𝜃
 
sin30' = 0.5
cos60' = 0.5
tan45' = 1
 
arc~는 해당 함수의 라디안 값 반환

내적 : a · b = |a| |b| cos𝜃 = ax * bx + ay * by + az * bz
	  결과는 스칼라값. 두 벡터가 수직일때 0, 양수->90도 이하, 음수->90도 이상.

외적 : 두 벡터에 모두 수직인 벡터를 구하는 공식
	  결과는 벡터값, 두 벡터가 평행일때 0
	  외적할 벡터 순서로 손을 감쌀때, 엄지의 위치가 결과 벡터의 방향

법선벡터(normal vecter) : 어떤 평면에 수직인 벡터



@ 행렬

곱할 행렬의 내항이 일치, 결과는 외항이 됨
	영향 받는 좌표
	향    x y z w			행렬의 곱은 내적과 같다.
	주 x  s 0 0 0			각 정점(x, y, z, w)과  행렬(4x4)을 연산.
	는 y  0 s 0 0			Scale-Rotation-Tranlate순 (S*R+T) 이동은 값만 더해줘도 됨.
	좌 z  0 0 s 0			행렬끼리 미리 곱하고 정점에 곱해 연산을 줄임.
	표 w  tex tex tex 1			회전 연산시 회전하려는 축을 제외하고 cos-sin-sin-cos 연산.
							-> 2d 회전은 z축 회전이며, cssc 연산은 사실상 z축을 제외하고 돌린것
회전을 할때 행렬로 돌리면 좌표축 자체가 바뀌어,
사원수를 이용해 연산하고 그 결과를 행렬로 변환해 넘겨 처리한다.


행렬식	 : 행렬을 스칼라 값으로 표현한 것. -> det(A)
		   // 사로스 공식
소행렬식 :  각 차원의 행렬을 쪼개고 쪼개 2x2 행렬로 만들어 행렬식을 구함.
			각 행렬의 원소가 있는 줄을 제외한 원소중 AD - BC를 계산 -> 새로운 행렬을 만들고,
			그 행렬의 각 원소 * AD-BC로 원소들을 계산한 결과가 행렬식.

수반행렬 : 여인수 행렬의 역행렬이란다

전치행렬 : 행렬의 행과 열을 반전시킨것, 주대각선을 기준으로 회전시키면 됨.

역행렬   : 어떤 행렬과 곱한 결과가 단위행렬이 되는 행렬, 연산행렬에 역행렬을 곱하면 결과가 되돌아감.
		   정방(정사각)행렬 중 행렬식이 0이 아닌 행렬에만 존재.
		   -> 직교 행렬에서는 무조건 역행렬이 존재하며, 전치행렬 = 역행렬 이다.
			  역행렬 = 1 / 행렬식 * 수반행렬
		  


		   WM          VM         PM           
@ 로컬좌표 -> 월드좌표 -> 뷰 좌표 -> 투영 좌표 -> 뷰표트 좌표 -> 화면 좌표

각 변환 행렬을 통해 좌표를 변환시킴
 -> 로컬 공간의 좌표를 월드 공간으로 옮기고, 카메라를 통해 본 공간이 그 카메라의 투영 좌표가 된다,
	그 공간을 옮길 뷰포트로 바꾸고, 최종적으로 화면에 해당하는 뷰포트를 그린다.


	
@ 뷰(카메라) : 월드 좌표 상에서 직접 보이는 공간 (단위벡터)

Look 벡터  : 카메라의 방향 벡터, (타겟 - 포지션)
Up'  벡터  : Up 벡터를 계산하기 위한 벡터 -> 일단 (0, 1, 0) 씀,
Up	 벡터  : Look 벡터에 직교하는 벡터.
	1. Look과 Up`의 내적(a라 명칭)하고 Up` - a 연산시 Up이 만들어짐
	2. Side와 Look을 외적해도 Up벡터가 만들어짐
Side 벡터  : Look과 Up(`)을 외적하여 Side 벡터 생성.

뷰 행렬(VM) = TR -> (TR)-1
	뷰행렬(이동)				->	전치행렬(역행렬)
	SideX	SideY	SideZ	0	->	SideX	LookX	UpX		0
	LookX	LookY	LookZ	0	->  SideY	LookY	UpY		0
	UpX		UpY		UpZ		0	->	SideZ	LookZ	UpZ		0
	PosX	PosY	PosZ	1	->	-PosX	-PosY	-PosZ	1
	
카메라라는것은 실제로 존재하진 않고 그 포지션 값을 이용해서 다른 모든 정점에 뷰 행렬을 연산시켜 오브젝트로 카메라쪽으로 보이도록 하는것이다
따라서 다른 정점들에 뷰행렬의 역행렬을 연산해 이동, 회전시킨다.

near, far : 카메라에서 보이게 할 최소, 최대 거리 -> 구간 사이의 공간은 0.0 ~ 1.0의 값으로 변환되고, 그 안에 들어온 점들만 보인다.
카메라각  : 카메라가 볼 수 있는 최대 각도
원근 투영 : 카메라를 기준으로 점차 넓어지는 사각뿔 형태로 투영 (투영하는 면적이 점점 넓어지니 멀어질수록 상대적으로 작게 보임)
직교 투영 : 카메라의 위치에 상관없이 동일한 크기로 투영(..2d, UI)

3인칭 카메라
	- 카메라가 지형에 가리지 않도록 카메라 위치와 캐릭터, 지형 비교해서 y값 잡아줌
	- 카메라와 목표가 있으면 회전된 목표가 바라보는 방향 반대로 반지름(거리)만큼 이동시키면 회전됨(기저축 회전)



로컬 좌표 -> 월드 좌표 -> (뷰 행렬) -> 투영 좌표 -> (뷰포트 행렬) -> 화면 좌표

뷰포트	   : 화면에 뿌릴 영역
뷰포트 행렬 : 투영 좌표계에서 뷰포트 행렬 곱해 화면 좌표계로 바꾸는것, 화면을 여러 뷰포트로 나누어 뿌릴수도 있음.
	W/2		0		0		 0				W, H는 화면의 영역
	0		-H/2	0		 0				x, y는 화면의 뿌릴 시작 좌표
	0		0		max-min  0				min, max는 z(Depth)값의 범위
	x+W/2	y+H/2	min		 1



@ 그래픽 파이프라인

입력 어셈블러(Input-Assembler) : 기본 요소 및 인접 데이터를 파이프라인에 제공, 쉐이더 효율성 높임
-> 정점 쉐이더	: 각 정점에 대한 연산을 수행, 단일 입력:단일 출력,							  =>헐 쉐이더
-> 헐   쉐이더  : 정점을 어떻게 얼마나 분할할지 결정하는 데이터를 계산.  (도메인 쉐이더 필요) =>도메인 쉐이더
   테셀레이터   : 헐 쉐이더에서 넘어온 패치 상수를 가지고 제어점을 알아서 쪼개줌.
->도메인쉐이더  : 헐 쉐이더와 테셀레이터를 통해 분할된 정점의 볼륨감을 정함. (헐 쉐이더 필요) =>레스터라이저
-> 기하 쉐이더  : 폴리곤의 새로운 기준을 잡아서 정점의 수를 늘리거나 줄임.					  =>레스터라이저
->레스터라이저  : 각 정점으로 이루어진 폴리곤에 대해 뿌려야 할 픽셀의 수 등을 연산 (..백페이스컬링)
-> 픽셀 쉐이더	: 화면에 뿌릴 픽셀에 대한 컬러, 라이팅, 텍스쳐 등을 처리 (=>렌더 타겟 표면)
-> 출력 병합기(OutputMerger) : 다양한 유형의 출력 데이터를 결합해 최종 파이프라인 결과를 생성
   연산 쉐이더  : GPGPU 연산에 사용


페이스컬링(레스터라이저) : 화면 상의 보이는 면의 정면, 후면에 따라 보일 속성을 지정 
						   (대상 면의 법선이 카메라 쪽을 향한다면 정면)



상수(constant) 버퍼 : 쉐이더 연산시 계속 연산하는 메모리(행렬, 조명?)를 상수화시켜 CPU와 GPU의 부하를 줄임.

깊이   버퍼 : 화면 버퍼와 별도로 버퍼를 지정해, 픽셀을 뿌릴때마다 픽셀의 깊이 값을 깊이 버퍼에 입력.
				해당 버퍼 픽셀의 깊이와 뿌릴 픽셀의 깊이를 비교해 뿌릴지 결정.(0.0 ~ 1.0)
				깊이 값의 비교와, 출력은 별개로 취급됨.

스텐실 버퍼 : 스텐실 연산을 통해 스텐실 버퍼에 값을 기입하고, 그 값에 따라 여러 효과를 연출.
				깊이 테스트가 꺼져있거나, 통과시에 스텐실 연산이 일어남.
				ReadMask와 WriteMast에 각각 읽을떄와 쓸때 비트 연산이 일어남 -> 보통 0xFF으로 And 연산 시킴(0으로 바꿀땐 0)
				전면과 후면에 각각 옵션을 설정 -> 스텐실 비교 방법과 : 깊이, 스텐실 연산이 통과, 실패시 연산을 지정 가능
				연산시 스텐실 참조값(보통 1or0)에 연산, 스텐실 버퍼에 
				블렌더와 혼합하여 컬러, 깊이 없이 스텐실 값만 넣을 수 도 있다.
				물체 뒤의 실루엣, 이펙트나 물체를 투영시켜 스텐실 연산으로 그림자를 표현(평면만)
				보통 스텐실 연산만 해서 한번 랜더링 후, 그 값에 따라 2차 랜더를 한다칸다.

알파테스트 	- 픽셀 쉐이더에서 조건에 따라 discard문으로 픽셀 처리를 제외하거나,
			  깊이 연산 등으로 뿌리고 안뿌리고 결정.


정점의 요소
	좌표값	(x, y, z, w) : 해당 정점의 위치
	법선벡터(x, y, z)	 : 해당 정점의 법선(단위벡터)
	컬러	(r, g, b, a) : 연산할 컬러(+음영)
	텍스쳐	(s, tex)		 : 연산할 텍스쳐 좌표(0.0 ~ 1.0)
-> 각 정점이 지닌 요소(Input)와 쉐이더 연산후 출력되는 결과(Output)의 요소는 다를 수 있다.